"""
Work Package 6 - IMU Filtering
Authors: G. Liang, A. Bauer, N. Meyners, L. Mueller
Course: PlanEx SoSe 20
License: MIT
Description:
Script for Post Processing simulation data from a csv file. Files are generated by simulationcontroller.py and a running
Gazebo simulation. EKF tuning parameters have to be adjusted in ori_estimation after adding bias or changing the system.

"""

#!/bin/python
import numpy as np
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt

from kalman import quaternion_tools as qtool
from kalman import ori_estimation
from kalman import pos_estimation

class EkfEstimation:
    def __init__(self, df):
        self.df = self.cleanup_df(df)
        self.real_quat = self.real_df(df)
        self.rate = 50

        # orientation estimation
        self.ekf_wrapper()
        # position estimation
        self.pos_wrapper()

    def real_df(self, df):
        """
        Extracts time and quaternion of orientation from the Gazebo for comparison. Returns pandas frame with
        quaternions of real orientation.

        :param df: Cleaned up Pandas Frame of csv
        :return: df_real
        :rtype df_real: pd.DataFrame

        """
        df_real = pd.DataFrame(data={
            "time": df.time_seconds + df.time_nseconds / 1e9 - df.time_seconds.iloc[0],
            "quat_w": df.orientation_w,
            "quat_x": df.orientation_x,
            "quat_y": df.orientation_y,
            "quat_z": df.orientation_z
        })
        return df_real

    def cleanup_df(self, df):
        """
        Extracts time, gyro, acc and mag data from csv and puts it into a Dataframe.
        :param df: all csv data
        :type df: pd.DataFrame
        :return: df_clean
        :rtype df_clean: pd.DataFrame
        """
        df_clean = pd.DataFrame(data={
            "time": df.time_seconds + df.time_nseconds / 1e9 - df.time_seconds.iloc[0],
            "gyro_x": df.angular_velocity_x,
            "gyro_y": df.angular_velocity_y,
            "gyro_z": df.angular_velocity_z,
            "acc_x": df.linear_acceleration_x,
            "acc_y": df.linear_acceleration_y,
            "acc_z": df.linear_acceleration_z,
            "mag_x": df.mag_x,
            "mag_y": df.mag_y,
            "mag_z": df.mag_z})

        return df_clean

    def ekf_wrapper(self):
        """
        Prepares the data for the EKF and handles the iteration.
        """

        # transform sensor readings to numpy frames for calculations because ori_estimation requires ndarrays
        ds_gyr = self.df[['gyro_x', 'gyro_y', 'gyro_z']].to_numpy()
        ds_acc = self.df[['acc_x', 'acc_y', 'acc_z']].to_numpy()
        ds_mag = self.df[['mag_x', 'mag_y', 'mag_z']].to_numpy()

        # initial first state from accmag, both rotated 180deg around z (imu heading is wrong)
        quat = np.array([qtool.quaternion_from_accmag(
            qtool.vec_rotate_z(np.pi, ds_acc[0,]),
            qtool.vec_rotate_z(np.pi, ds_mag[0,])).T])

        for i in range(1, ds_gyr.shape[0]):
            if i == 1:
                P = np.eye(4)
                quat_post, P = ori_estimation.ekf_ori_estimation(P, self.rate, ds_gyr[i - 1,], quat[0,], ds_acc[i,],
                                                                 ds_mag[i,])
            else:
                quat_post, P = ori_estimation.ekf_ori_estimation(P, self.rate, ds_gyr[i - 1,], quat[i - 1,], ds_acc[i,],
                                                                 ds_mag[i,])
            quat = np.append(quat, [quat_post], axis=0)
        self.quat = quat

    def pos_wrapper(self):
        """
        Prepares the data for position estimation and handles the iteration.
        """

        # accelerometer data to numpy array for calculations because ori_estimation requires ndarrays
        acc = self.df[['acc_x', 'acc_y', 'acc_z']].to_numpy()

        # list to collect positions
        pos_list = []
        # initial position
        pos_sum = np.array([0, 0, 0])
        quat = self.quat
        for i in range(quat.shape[0]):
            pos_sum, vel_sum = pos_estimation.pos_estimation(self.rate, quat[i,], acc[i,], pos_sum)
            pos_list.append(pos_sum)
        pos_list = np.array(pos_list)

        # plot
        fig = plt.figure()
        axes = plt.axes()
        axes.set_xlabel('x')
        axes.set_ylabel('y')

        line = axes.plot(pos_list[:, 0], pos_list[:, 1], 'green')
        plt.axis('equal')
        plt.show()


if __name__ == "__main__":
    fpath = Path("data")
    fname = "turtle2.csv"
    df = pd.read_csv(fpath / fname, sep="\t")
    call = EkfEstimation(df)
